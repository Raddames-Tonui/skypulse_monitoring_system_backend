package org.skypulse.handlers.services;

import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import org.skypulse.config.database.JdbcUtils;
import org.skypulse.utils.ResponseUtil;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;

/**
 {
 "page": 1,
 "size": 10,
 "total": 34,
 "pages": 4,
 "services": [
 {
 "monitored_service_id": 1,
 "name": "Impala Docs",
 "url": "https://impala-docs.netlify.app/",
 "region": "Kenya",
 "check_interval": 5,
 "retry_count": 3,
 "retry_delay": 5,
 "expected_status_code": 200,
 "ssl_enabled": true,
 "created_at": "2025-11-20T10:00:00Z",
 "updated_at": "2025-11-20T10:00:00Z"
 }
 ]
 }

 */

/**
 Explanation:

 exchange.isInIoThread()

 Returns true if the current request is running in an I/O thread.

 I/O threads are meant to be non-blocking and handle lots of connections quickly.

 You should not perform long/blocking operations (like DB queries, file I/O) directly in the I/O thread because it will block other requests.

 exchange.dispatch(this)

 Offloads the execution of this handler to a worker thread from Undertow’s worker thread pool.

 The this refers to the current handler, so it will be called again in the worker thread.

 return;

 Prevents the code from continuing in the I/O thread after dispatching.

 When dispatched, the handler will resume execution on the worker thread, where blocking operations are safe.

 ✅ In short:

 This pattern ensures safe blocking operations (like DB access) while keeping the I/O thread responsive.

 Without it, doing blocking operations in an I/O thread can freeze your server under load.

 */
/
public class GetMonitoredServicesHandler implements HttpHandler {

    // Whitelist DB columns that are allowed for sorting
    private static final Set<String> SORTABLE_COLUMNS = Set.of(
            "monitored_service_name",
            "monitored_service_url",
            "monitored_service_region",
            "check_interval",
            "date_created",
            "last_updated",
            "is_active"
    );

    @Override
    public void handleRequest(HttpServerExchange exchange) throws Exception {

        if (exchange.isInIoThread()) {
            exchange.dispatch(this);
            return;
        }

        Map<String, Deque<String>> params = exchange.getQueryParameters();

        // -------- Pagination --------
        int page = parseIntParam(params.get("page"), 1);
        int size = parseIntParam(params.get("size"), 10);

        int offset = (page - 1) * size;

        // -------- Filtering (optional) --------
        String filterName = getParam(params, "monitored_service_name");
        String filterRegion = getParam(params, "monitored_service_region");
        String filterActive = getParam(params, "is_active");

        StringBuilder sql = new StringBuilder(
                "SELECT * FROM monitored_services WHERE 1=1 "
        );

        List<Object> dbParams = new ArrayList<>();

        if (filterName != null && !filterName.isBlank()) {
            sql.append(" AND monitored_service_name ILIKE ? ");
            dbParams.add("%" + filterName + "%");
        }

        if (filterRegion != null && !filterRegion.isBlank()) {
            sql.append(" AND monitored_service_region ILIKE ? ");
            dbParams.add("%" + filterRegion + "%");
        }

        if (filterActive != null && !filterActive.isBlank()) {
            sql.append(" AND is_active = ? ");
            dbParams.add(Boolean.parseBoolean(filterActive));
        }

        // -------- Sorting --------
        String sortParam = getParam(params, "sort");
        String orderBy = buildOrderBy(sortParam);
        sql.append(orderBy);

        // -------- Pagination appended --------
        sql.append(" LIMIT ? OFFSET ? ");
        dbParams.add(size);
        dbParams.add(offset);

        // Execute
        List<Map<String, Object>> result = DatabaseUtil.query(sql.toString(), dbParams);

        ResponseUtil.sendJson(exchange, StatusCodes.OK, result);
    }

    // -------- Helpers --------

    private String getParam(Map<String, Deque<String>> params, String key) {
        Deque<String> deque = params.get(key);
        if (deque == null) return null;
        return deque.peekFirst();
    }

    private int parseIntParam(Deque<String> deque, int defaultValue) {
        try {
            return deque == null ? defaultValue : Integer.parseInt(deque.peekFirst());
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * Parses "sort=name:asc,date_created:desc"
     */
    private String buildOrderBy(String sortParam) {
        if (sortParam == null || sortParam.isBlank()) {
            return " ORDER BY date_created DESC ";
        }

        String[] entries = sortParam.split(",");
        List<String> orderSql = new ArrayList<>();

        for (String entry : entries) {
            String[] parts = entry.split(":");
            if (parts.length != 2) continue;

            String column = parts[0].trim();
            String direction = parts[1].trim().toUpperCase();

            // Validate column name
            if (!SORTABLE_COLUMNS.contains(column)) continue;

            // Validate direction
            if (!direction.equals("ASC") && !direction.equals("DESC")) {
                direction = "ASC";
            }

            orderSql.add(column + " " + direction);
        }

        if (orderSql.isEmpty()) {
            return " ORDER BY date_created DESC ";
        }

        return " ORDER BY " + String.join(", ", orderSql) + " ";
    }
}
